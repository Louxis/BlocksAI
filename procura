;;;Searching algorithms
;;;Made by José Pereira and Lyudmyla Todoriko
;;;The node structure is {(board) (pieces remaining) (parent node) (g) (optional h and f)

(defparameter *open* nil)
(defparameter *close* nil)
;;BF search
(defun bf_it (node &optional p)
  (setq *open* (append *open* node))  
  (loop while (not (null *open*))
        do 
        (let ((currentNode (car *open*)) (expandedNodes (expandNode (car *open*))))
        (setq *close* (append *close* currentNode)) 
        ;Remove current node from *open*
        (setq *open* (cdr *open*))
        ;Add expanded nodes to the *open* list
        (setq *open* (append *open* expandedNodes))
        ;If one of them is a finishing node, stop the loop returning the finish node
        (if (not (null (finishNode expandedNodes))) (return (finishNode expandedNodes))))))

;;DF search
(defun df_it (node &optional p)
  (setq *open* (append *open* node))  
  (loop while (not (null *open*))
        do 
        (let ((currentNode (car *open*)) (expandedNodes (expandNode (car *open*))))
        (setq *close* (append *close* currentNode)) 
        ;Remove current node from *open*
        (setq *open* (cdr *open*))
        ;Add expanded nodes to the *open* list
        (setq *open* (append expandedNodes *open*))
        ;If one of them is a finishing node, stop the loop returning the finish node
        (if (not (null (finishNode expandedNodes))) (return (finishNode expandedNodes))))))



;;placeholders
;;Returns the finishing node of a list of nodes
(defun finishNode (nodes) nil)
(defun expandNode (node) nil)
